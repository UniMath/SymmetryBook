\documentclass[a4paper,12pt]{amsart}
\input macros
\hypersetup{pdfauthor={Bezem-Buchholtz-Grayson},
  pdftitle={Construction of the Circle in UniMath}}
\begin{document}
\newcommand{\UniMath}{\emph{UniMath}}
\title{Construction of the circle in \UniMath}
{
    \author{Marc Bezem}
    \address{Department of Informatics, University of Bergen}
    \email{marc.bezem@uib.no}
    % \urladdr{https://www.uib.no/en/persons/Marcus.Aloysius.Bezem}
}
{
    \author{Ulrik Buchholtz}
    \address{Department of Mathematics, Technische Universit\"at Darmstadt}
    \email{ulrikbuchholtz@gmail.com}
    \urladdr{https://www2.mathematik.tu-darmstadt.de/~buchholtz/}
}
{
    \author{Daniel R. Grayson}
    \email{danielrichardgrayson@gmail.com}
    \urladdr{http://dangrayson.com/}
}

\date{May 17, 2019}

\begin{abstract}
We show that the type $\TorZ$ of $\ZZ$-torsors has the dependent universal property of the circle, 
which characterizes it up to a unique homotopy equivalence.  
The construction uses Voevodsky's Univalence Axiom and propositional truncation, 
yielding a stand-alone construction of the
circle not using higher inductive types.
\end{abstract}

\maketitle
\markleft{BEZEM BUCHHOLTZ GRAYSON}
\markright{CONSTRUCTION OF THE CIRCLE}
\tableofcontents

\section{Introduction}

In set theoretic foundations of mathematics, the {\em sets} have no interesting internal structure, aside from the identity of their elements.
By contrast, in homotopy type theory and Voevodsky's univalent foundations, the {\em types} are the fundamental objects, serving to classify the
objects of mathematics.  They behave much like (homotopy types of) spaces, due to the promotion of isomorphisms between objects to
equalities, together with the intuition that an equality between two objects of the same type is like a path between two points in the same
space.

{\em Synthetic homotopy theory} is the study of the homotopy theoretic properties of types.  It is a fruitful one, because it turns out that
many of the most basic results of standard homotopy theory have true analogues for types, even though the framework, based purely on logical
principles, is devoid of the features one normally associates with topology, such as the topology of the real numbers.

In standard homotopy theory it is well known that the {\em classifying space} of the group $\ZZ$ of integers is homotopy equivalent to the
circle.  The traditional algebraic notion of $\ZZ$-torsor yields a category all of whose arrows are isomorphisms, all of whose objects are
isomorphic to each other, and a trivial $\ZZ$-torsor whose automorphism group is $\ZZ$.  Due to univalence, the type $B\ZZ$ of all $\ZZ$-torsors
is a connected pointed type whose fundamental group is $\ZZ$; we may call it the {\em classifying type} of $\ZZ$.  In this paper we show that
$B\ZZ$ behaves the way a circle ought to behave, by establishing that maps from it to other types (or families of types) are freely determined
by the destinations of the base point and the canonical loop at the base point (corresponding to the element $1$ of $\ZZ$).  The proof is
constructive, in that it does not appeal to the axiom of choice or the law of the excluded middle.

There are various types equivalent to the type of $\ZZ$-torsors, and thus they also provide constructions of circles: all one needs is a
connected pointed type whose automorphism groups are isomorphic to $\ZZ$.  For example, if one arising from geometry is desired, one may
consider the type consisting of all frieze patterns in a Euclidean plane\footnote{We say \emph{a} Euclidean plane instead of {\em the} Euclidean
  plane to indicate that the type is actually the type of pairs consisting of a Euclidean plane and such a frieze pattern in it.} formed from a
linear collection of evenly spaced copies of the letter $F$.
$$ \cdots FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF \cdots $$

We have formalized the result in \UniMath{}, a name which refers both to a (univalent) foundation of mathematics based on a formal type theoretic
language and to a particular repository \cite{UniMath} of formalized proofs, encoded in the language of the proof assistant {\em Coq}.

The other standard way to construct a circle in type theory uses {\em higher inductive types}, where one posits a new type, an element of it, a
path from the element to itself, and nothing more.  Since {\UniMath}, by a conservative convention aimed at minimizing the burden of proving
consistency of the formal system, does not use higher inductive types, the construction presented here is the only way to construct a circle in
\UniMath{}.  Adding higher inductive types to the system would give another construction of the circle, equivalent to the one described above.

Now we give a few more details.

As a prerequisite we require, of the reader, a working knowledge of homotopy type theory
as described in, for example, the first four chapters of \cite{hottbook}.
One extra piece of knowledge we use here is the \emph{dependent} elimination
principle for propositional truncation, mentioned in \cite[Ch. 6.9]{hottbook},
and qualified as `not really useful'%
\footnote{The dependent elimination principle appears to 
  be used later in \cite{hottbook}, though.
  %% see the issue we made at https://github.com/HoTT/book/issues/1028
}.
We use this principle in \cref{lem:dep-elim-TorZ}, and the paragraph after
its proof gives some extra attention to the computational aspect.

For convenience we give a direct inductive
definition of the set of integers in \cref{sec:integers}.
Thus we get a set of integers $\zet$, a constant $0:\zet$,
and a successor function $s:\zet\to\zet$
that is an equivalence.
Considering pairs $(X,f)$ of type $\sum_{X:\UU}(X\to X)$,
we can introduce \emph{the 
pointed type of $\zet$-torsors} by adopting the following definitions.
\begin{align*}
  \TorZ &\defeq \sum_{(X,f)}\Trunc{(\zet,s)=(X,f)}  \\
  \pt & \defeq ((\zet,s),\trunc{\refl{(\zet,s)}}) : \TorZ
\end{align*}
It is not difficult to see 
that the type $\pt =_\TorZ \pt$ is equivalent to $\zet$.  To see that,
begin by observing that every function $f:\zet\to\zet$ commuting with $s$
is propositionally equal to $s^{f(0)}$.  The first projection
acting on $p : \pt =_\TorZ \pt$ gives a path $\mathsf{pr}_1(p) : \zet=\zet$
such that the corresponding transport function $\mathsf{pr}_1(p)_* : \zet\to\zet$
is a bijection commuting with $s$. We evaluate this bijection in $0$.
Let $\ev_0(p) \defeq \mathsf{pr}_1(p)_*(0)$ for all $p : \pt =_\TorZ \pt$,
then $\ev_0 : (\pt =_\TorZ \pt) \to \zet$.  Combining these observations,
using the univalence axiom, one proves that $\ev_0$ is an equivalence.

We define $1 \defeq s(0)$.
The preimage of $1$ under the equivalence $\ev_0$ is a
natural generating path of $\pt =_\TorZ \pt$, so we define
${\Zloop}\defeq \ev_0^{-1}(1)$, which we call the \emph{loop}
of $\TorZ$. Alternatively, we could have obtained $\Zloop$
directly from $s: \zet\equiv\zet$ by applying the univalence axiom
(with some easy add-ons, e.g., proving that $s$ commutes with itself).

With this in hand, we can formulate a recursion principle for $\TorZ$.
It states that, given a type $A$, an element $a$ of $A$ and a
path $l:a=_A a$, one can construct a function $f:\TorZ\to A$
such that $f(\pt)\jdeq a$ and $\ap{f}(\Zloop)=l$.
(This construction was formalised by Grayson 
in 2014, see \cite{circlerec-Dan}; our construction here uses the 
same basic idea but manages the computations involved in establishing the
induction principle better.)  We call the resulting function
\[
{\rec}_A : \sum_{a:A}(a=a) ~~\to~~ (\TorZ \to A).
\]

The universal property of the circle for $\TorZ$
states that ${\rec}_A$ above is an equivalence, for all types $A$.
In order to prove this universal property one needs an induction
principle, in which $A$ is not a type but a type family over $\TorZ$.
On the basis of Grayson's construction of the recursion principle,
Shulman sketched an approach to the induction principle, see \cite{circleind-Mike}. 
Independently of this, but also departing from Grayson's proof of the 
recursion principle, Buchholtz and Bezem found the construction
presented in this paper, which has subsequently been formalized
by Grayson \cite{circleind-Dan,circleind-Dan-theorem} in \UniMath.  

The precise statement of the induction principle is that there is a 
function of the following type:
\begin{equation}
  \label{circleinductionequation}
  \thinmuskip=10mu              % this is better than inserting tildes
  \prod_{A: \TorZ\to\UU}
  \prod_{a: A(\pt)}
  \prod_{l: a=^A_{\Zloop} a}
  \sum_{f: \prod_{z:\TorZ} A(z)}
  \sum_{r: f(\pt)= a}
  {\apd{f}(\Zloop) = r\cto' l \cto r^{-1}}
\end{equation}
Here $\apd{}$ is as defined in \cite[Ch. 2.3]{hottbook}.
Note that $r$ above is a path between two elements of the same fiber $A(\pt)$.
Hence $r$ and $r^{-1}$ are paths over $\refl{\pt}$ and can be composed with $l$.
To simplify the statement, we use the \emph{left recursive} 
composition $\cto'$ of paths over paths and the \emph{right recursive} $\cto$ composition of paths over paths.
(A composition operation is called \emph{left recursive} if it computes to its right-hand argument when its
 left-hand argument is given by reflexivity; similarly with \emph{left} replaced by \emph{right}.)

\begin{figure}
  \centering
  \begin{tikzpicture}
    \foreach \x in {0,2,4}
    { \begin{scope}[shift={(\x,0)}]
        \foreach \y in {0,1,3}
        { \begin{scope}[shift={(0,\y)}]
            \draw (0,0) .. controls ++(170:-.3) and ++(210: .4) .. (1,0)
                        .. controls ++(210:-.4) and ++(170: .3) .. (2,0);
          \end{scope} }
        \node[fill,circle,inner sep=1pt,label=below:$\pt$] at (1,0) {};
        \node[fill,circle,inner sep=1pt,label=below left:$a$] at (1,1.6) {};
        \node[fill,circle,inner sep=1pt] at (1,2.5) {};
        \draw (1,1) -- (1,3);
        \node at (1,3.5) {$A(\pt)$};
        \draw[dashed] (0,2.4) .. controls ++(150:-.5) and ++(190: .3) .. (1,2.5)
                              .. controls ++(190:-.3) and ++(150: .5) .. (2,2.4);
        \draw[thick,dashed] (1,2.5) -- (1,1.6);
        \node at (1.2,2) {$r$};
      \end{scope} }
    \foreach \x in {0,2}
    { \begin{scope}[shift={(\x,0)}]
        \draw (1,1.6) .. controls ++(140:-.4) and ++(190:.3) .. (2,1.8)
                      .. controls ++(190:-.3) and ++(140:.4) .. (3,1.6);
        \node at (2,1.5) {$l$};
        \node at (2,-.3) {$\Zloop$};
      \end{scope} }
    \foreach \y in {0,2} {
      \node at (-.5,\y) {$\cdots$};
      \node at (6.5,\y) {$\cdots$};
    }
    \node (T) at (-1.5,0) {$\TorZ$};
    \node (A) at (-1.5,2) {$A$};
    \node (f) at (0.3,2.6) {$f$};
  \end{tikzpicture}
  \caption{A visualization of circle induction principle}
  \label{fig:circle-induction}
\end{figure}

The type in \cref{circleinductionequation} is illustrated in \cref{fig:circle-induction}.
We think of $\TorZ$ as a circle (and prove that it is),
but we illustrate it (and objects depending on it) as periodically recurring,
in order to make clearer diagrams.
The type $\apd{f}(\Zloop) = r\cto' l \cto r^{-1}$ is equivalent to
$\apd{f}(\Zloop) =^{\lambda z, z=^A_{\Zloop}z}_r l$,
and corresponds to filling the inside of the curvilinear quadrilateral in \cref{fig:circle-induction}.

If the underlying type theory has propositional truncation with a dependent eliminator that computes judgmentally on the point constructor, as
in \cite[Ch. 6.9]{hottbook}, then the path $r : f(\pt)= a$ above is a reflexivity path.
It then follows
from the care with which we chose the expression $r\cto' l \cto r^{-1}$, that it has the same type as $l$, and, moreover, the two terms are
judgmentally equal.  Thus the right side of the equation \ref{circleinductionequation} can be replaced by $l$.

Because the convention in {\UniMath} is to avoid higher inductive types,
the formalization in \cite{circleind-Dan} is
slightly different from the construction presented below.
The formalized construction does not use any higher inductive types,
relying instead on the construction of propositional truncation as
(the propositional resizing of)
$\Trunc X \defeq \prod_{P:\Prop}((X \to P) \to P)$.
Nor of course, and this is the whole point, do we
depend on the previous existence of a type satisfying the induction principle of the circle. 

In a type theory where higher inductive types are admitted,
one can introduce a circle $\Sc$ as a higher inductive type, 
as in \cite[Ch. 6.1]{hottbook}, and it will easily be shown to be equivalent to $\TorZ$.
The equivalence can be established by observing that $\TorZ$ and $\Sc$ 
are pointed connected types with loop spaces equivalent to $\zet$.
(For the interested reader: apply \cite[Lemma 7.6.2]{hottbook} with $n=-2$
to reduce to action on paths. Then use connectedness to strengthen
this result from embeddings to equivalences. 
Finally, again using connectedness, reduce to the loop spaces
of the respective points, and show they are equivalent to $\zet$ and thus to each other.)
The induction principle \cref{circleinductionequation} for $\TorZ$ then follows directly.

One can construct models of type theory with univalent universes and propositional resizing
(viz., essentially of \UniMath{})
that do not have higher inductive types, not even suspensions.
Indeed, we can take any model and restrict the $n$th universe, $n=0,1,\dots$,
to consist of homotopy $n$-types:
the new zeroth universe $\UU'_0$ consists of the sets of the old universe $\UU_0$,
the new universe $\UU'_1$ consists of the groupoids of $\UU_1$ (hence including $\UU'_0$),
etc.
This construction keeps all the propositions, so it preserves propositional resizing.
By our construction, $\UU'_1$ will contain a circle $\TorZ$,
but it cannot contain the $2$-sphere (the suspension of the circle),
as this is not a groupoid.
And, assuming we can verify that the $2$-sphere is not an $n$-type for any $n$,
then no universe in the new model will contain a $2$-sphere.

\section{The integers}
\label{sec:integers}

We define the type of integers in one of the many possible ways.

\begin{definition}\label{def:integers}
Let $\zet$ be the inductive type with the following three constructors:
\begin{enumerate}[topsep=0pt]
\item $\zzero: \zet$ for the integer number zero, 
$0 \defeq \zzero$
\item $\zpos: \NN \to \zet$ for positive numbers,
$1 \defeq \zpos(0),\ldots$.
\item $\zneg: \NN \to \zet$ for negative numbers, 
$-1 \defeq \zneg(0),\ldots$
\end{enumerate}
\end{definition}

The \emph{embedding} function $i:\NN\to\zet$ is defined by induction,
setting $i(0)\defeq \zzero$, $i(S(n))\defeq \zpos(n)$.
Like the type $\NN$, the type $\zet$ is a set with decidable equality
and ordering relations,
and we denote its elements often in the usual way as $\ldots,-1,0,1,\ldots$.

One well-known equivalence is \emph{negation} ${-}:\zet\to\zet$, 
also called \emph{complement}, inductively defined by setting 
$-\zzero\defeq \zzero$, 
$-\zpos(n)\defeq \zneg(n)$, 
$-\zneg(n)\defeq \zpos(n)$.
Negation is its own inverse.

The \emph{successor} function $s:\zet\to\zet$ is defined inductively setting 
$s(\zzero)\defeq \zpos(0)$, 
$s(\zpos(n))\defeq \zpos(S(n))$,
$s(\zneg(n))\defeq -i(n)$. For example, we have
$s(-1)\jdeq s(\zneg(0))\jdeq -i(0) \jdeq \zzero \jdeq 0$.
By induction on $n:\NN$ one proves $s(i(n))=i(S(n))$, 
so that one can say that $s$ extends $S$ on the $i$-image of $\NN$. 
From now on we will identify $i(n):\zet$ with $n$,
and $-i(n):\zet$ with $-n$, for all $n:\NN$.

The successor function $s$ is an equivalence.
%It is instructive to depict iterating $s$ in both directions as 
%a doubly infinite sequence containing all integers:
%\[
%\ldots \mapsto \zneg(1) \mapsto \zneg(0) \mapsto \zzero \mapsto \zpos(0) \mapsto \zpos(1) \mapsto \ldots
%\]
The inverse $s^{-1}$ of $s$ is called the \emph{predecessor} function.
We denote the $n$-fold iteration of $s$ as $s^n$, and
the $n$-fold iteration of $s^{-1}$ as $s^{-n}$.

Addition of integers is defined inductively by setting
$z + \zzero\defeq z$, 
$z + \zpos(n)\defeq s^{n+1}(z)$, 
$z + \zneg(n)\defeq s^{-(n+1)}(z)$.
%Again, addition extends $+$ on the $i$-image of $\NN$,
%see \cref{xca:addition-on-Z-and-N}. 
From addition and unary $-$ one can define a binary
\emph{substraction} function setting $z-y \defeq z+(-y)$.

%\begin{xca}\label{xca:addition-on-Z-and-N}
%Show that $i(n+m)=i(n)+i(m)$ for all $n,m:\NN$.
%\end{xca}

Recall the equivalence $\ev_0 : (\pt=_\TorZ \pt)\to\zet$ from the introduction.
We have $\refl{\pt} : \pt=_\TorZ \pt$, as well as the operations
of \emph{path reversal} and \emph{path composition} as defined
in \cite[Ch. 2.1]{hottbook}. These satisfy the laws as stated
and proved in \cite[Lemma 2.1.4]{hottbook}, equipping $\pt=_\TorZ \pt$
with a group structure.
The equivalence $\ev_0$ maps $\refl{\pt}$ via $\id_\zet : \zet\to\zet$ to $0$.
As explained in the introduction, $\ev_0$ maps any $p : \pt=_\TorZ \pt$
via $s^k : \zet\to\zet$ to some $k:\zet$. Since $(s^k)^{-1} = s^{-k}$
and $s^k \circ s^l = s^{k+l}$, $\ev_0$ transports path reversal 
and path composition to negation and addition, respectively.
This means that the entire group structure of $\pt=_\TorZ \pt$
is transported to the usual group structure on $\zet$,
including all the proofs of the group laws in $\zet$.
(The fact that we do not have to reprove the group laws
is one of the benefits of the univalent approach.)


\section{Some induction principles for the integers}
\label{sec:integers-induction}

The definition of $\zet$ yields the following induction principle.
Given $P : \zet \to \UU$, to construct elements $h(z) : P(z)$ for every $z : \zet$,
it suffices to give $h(0): P(0)$ and functions
$f : \prod_{n:\NN}(P(n) \to P(n+1))$ and
$g : \prod_{n:\NN}(P(-n) \to P(-n-1))$, 
as illustrated in \cref{fig:integers-induction-asymmetric}.

The function $h:\prod_{z:\ZZ}(P(z)$ thus defined satisfies
$h(n+1)\jdeq f(n,h(n))$ and $h(-n-1)\jdeq g(n,h(-n))$ for all $n:\NN$.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \foreach \x in {-2,-1,0,1,2} {
      \begin{scope}[shift={(\x,0)}]
        \draw (0,0) ellipse (0.2 and 0.8);
        \node[fill,circle,inner sep=1pt,label=below:{$\x$}] (P\x) at (0,-1.2) {};
      \end{scope}
    }
    \foreach \x in {0,1,2} {
      \begin{scope}[shift={(\x,0)}]
        \draw[->] (0.3,0) -- node[below] {\scriptsize$f\strut$} (0.7,00);
      \end{scope}
    }
    \foreach \x in {-3,-2,-1} {
      \begin{scope}[shift={(\x,0)}]
        \draw[->] (0.7,0) -- node[below] {\scriptsize$g\strut$} (0.3,00);
      \end{scope}
    }
    \node[fill,circle,inner sep=.8pt] at (0,0) {};
    \node at (-4,0) {$P$};
    \node at (-4,-1.4) {$\ZZ$};
    \foreach \x in {-3,3.1} {
      \foreach \y in {0,-1.2} {
        \node at (\x,\y) {$\cdots$};
      }
    }
  \end{tikzpicture}
  \caption{Asymmetric integer induction principle}
  \label{fig:integers-induction-asymmetric}
\end{figure}


It is possible to give a more symmetric, but less general induction principle,
if we assume that the functions are equivalences.
In that case we can reorient the $g$'s to point in the same direction as the $f$'s,
allowing us to combine them into a single family $f : \prod_{z:\zet}P(z) \equiv P(z+1)$ of equivalences, 
as illustrated in \cref{fig:integers-induction-symmetric}.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}
    \foreach \x in {-2,-1,0,1,2} {
      \begin{scope}[shift={(\x,0)}]
        \draw (0,0) ellipse (0.2 and 0.8);
        \node[fill,circle,inner sep=1pt,label=below:{$\x$}] (P\x) at (0,-1.2) {};
      \end{scope}
    }
    \foreach \x in {-3,-2,-1,0,1,2} {
      \begin{scope}[shift={(\x,0)}]
        \draw[->] (0.3,0) -- node[above] {\scriptsize$\sim$} node[below] {\scriptsize$f$} (0.7,00);
      \end{scope}
    }
    \node[fill,circle,inner sep=.8pt] at (0,0) {};
    \node at (-4,0) {$P$};
    \node at (-4,-1.4) {$\ZZ$};
    \foreach \x in {-3,3.1} {
      \foreach \y in {0,-1.2} {
        \node at (\x,\y) {$\cdots$};
      }
    }
  \end{tikzpicture}
  \caption{Symmetric integer induction principle}
  \label{fig:integers-induction-symmetric}
\end{figure}

We shall need that in this case, giving an element $h:\prod_{z:\zet}P(z)$
together with identities of type $h(z+1) = f_z(h(z))$ for all $z:\zet$
is equivalent to giving the single element $h(0)$.
We formulate this precisely as follows.

\begin{theorem}\label{thm:integers-univ-symm}
  Let $P : \zet \to \UU$ and $f : \prod_{z:\zet}P(z) \equiv P(z+1)$. The function
  \[
    \varphi : \biggl(\sum_{h:\prod_{z:\zet}P(z)}\prod_{z:\zet}h(z+1) = f_z(h(z))\biggr) \to P(0)
  \]
  that sends $(h,q)$ to $h(0)$ is an equivalence.
\end{theorem}
\begin{proof}
  We prove that the fiber over any $p : P(0)$ is contractible.
  We simplify notations a bit by leaving out the types of $h$ and $q$.
  The fiber $\sum_{(h,q)} h(0)=p$ consists of triples $(h,q,r)$ with $r : h(0) = p$.
  By case distinction, $h$ can (equivalently) be split in three parts $(h_-,h_0,h_+)$
  with $h_0 : P(0)$, $h_+ : \prod_{n:\NN}P(n+1)$,  and $h_- : \prod_{n:\NN} P(-n-1)$. 
  Since $h(0)=p$ only depends on $h_0$ the pair $(h_0,r)$ with  $r : h_0 = p$
  contracts away, so we're left with the type
  \begin{align*}
    \varphi^{-1}(p)
    &\equiv
      \Biggl(\sum_{h_+ : \prod_{n:\NN}P(n+1)}
      \bigl(h_+(0) = f_0(p)\bigr) \\
    &\qquad\qquad\qquad
      \times \biggl(\prod_{n:\NN}h_+(n+1) = f_n(h_+(n))\biggr)\Biggr) \\
    &\quad\times
      \Biggl(\sum_{h_- : \prod_{n:\NN}P(-n-1)}
      \bigl(h_-(0) = f_{-1}^{-1}(p)\bigr) \\
    &\qquad\qquad\qquad
      \times \biggl(\prod_{n:\NN}h_-(n+1) = f_{-n-2}^{-1}(h_-(n))\biggr)\Biggr).
  \end{align*}
  The latter type is contractible, because it is the product of two contractible types,
  each specifying a certain function $h_{\pm}:\prod_{n:\NN}Q_{\pm}(n)$,
  and saying that this function has a certain value at $0$
  and prescribing the values at successors.
  But such a specification is unique by the universal property (induction!) of $\NN$.
\end{proof}
Let us spell out the inverse function produced in the proof.
It maps $p : P(0)$ to a pair whose first component
is the function that takes $z:\zet$ to $f^z(p):P(z)$, where
\begin{alignat*}2
  f^0(p) &\defeq p, && \\
  f^{n+1}(p) &\defeq f_n(f^n(p)),&\quad&\text{for $n:\NN$,} \\
  f^{-n-1}(p) &\defeq f_{-n-1}^{-1}(f^{-n}(p)),&\quad&\text{for $n:\NN$.}
\end{alignat*}


\section{Identifying elements in members of families of types}
\label{sec:pathovers}

In this section we present some additional results that are needed in the sequel.
% and that cannot be found in \cite{hottbook}.

Let $A : \UU$, $B : A \to \UU$, $a_i:A$, $b_i:B(a_i)$ for $i=1,2$, and $p : a_1 = a_2$.
We are interested in identifications of $b_1$ and $b_2$ relative to this data.
We cannot in general form the type $b_1 = b_2$ as their types may be different.
There are several ways to solve this problem. One of them is to transport $b_1$ along
$p$ and form an identity type in $B(a_2)$. Another way would be to consider
identifications $(a_1,b_1) = (a_2,b_2)$ in $\sum_{x:A} B(x)$ and require that the
action of the first projection on such identifications is equal to $p$. 
These two ways are equivalent.
%The latter way has perhaps been the inspiration of the name `pathover'.
The former way is easier to work with and will be the one we choose here.

\begin{definition}\label{def:pathover}
Let $A : \UU$, $B : A \to \UU$, $a_i:A$, $b_i:B(a_i)$ for $i=1,2$, and $p : a_1 = a_2$.
Define the transport function $\trp{B,p} : B(a_1)\to B(a_2)$ by induction on $p$,
setting $\trp{B,\refl{a_1}}(b_1)\defeq b_1$. This is indeed well-typed since
$B(a_1)\jdeq B(a_2)$ in this case.
Now define the type $b_1 =^B_p b_2$ as $\trp{B,p}(b_1) = b_2$.
An element of $b_1 =^B_p b_2$ is called
a \emph{path} from $b_1$ to $b_2$ \emph{over} $p$.
Note that $(b_1 =^B_{\refl{a_1}} b_2) \jdeq (b_1 =_{B(a_1)}  b_2)$.
\end{definition}

Many of the operations on paths have their counterpart for paths over paths.
We define the unit path over a path, composition of paths over paths, and reversal of paths over paths.

\begin{definition}\label{def:pathoveralgebra}
  Let $A : \UU$, $B : A \to \UU$, $a_i:A$, $b_i:B(a_i)$ for $i=1,2,3$, and 
  $p_i : a_i = a_{i+1}$ for $i=1,2$. We define:
  \begin{enumerate}[topsep=3pt]
  \item \emph{Unit} $\refl{b_1} : b_1 =^B_{\refl{a_1}} b_1$;
  \item \emph{Composition of paths over paths} $\cto : b_1 =^B_{p_1} b_2 \to b_2 =^B_{p_2} b_3 \to b_1 =^B_{p_1 \ct p_2} b_3$,
    defined by induction first on $p_2$ and then on $r: b_2 = b_3$, by
    setting $q \cto \refl{b_2} \defeq q$ for all $q: b_1 =^B_{p_1} b_2$;
  \item \emph{Reversal of paths over paths} $({-})^{-o} : b_1 =^B_{p_1} b_2 \to b_2 =^B_{(p_1)^{-1}} b_1$,
    defined by induction first on $p_1$ and then on $r: b_1 = b_2$, by
    setting $\refloi{b_1} \defeq \refl{b_1}$.
  \end{enumerate}
\end{definition}

These operations on paths over paths satisfy many of the laws satisfied by the corresponding operations on paths, after some modification.  We
illustrate the modification required to treat composition.  Suppose we have elements $a_i : A$ for $1 \le i \le 4$, paths $p_i : a_i = a_{i+1}$
for $1 \le i \le 3$, elements $b_i:B(a_i)$ for $1 \le i \le 4$, and paths $q_i : b_i =^B_{p_i} b_{i+1}$ over $p_i$ for $1 \le i \le 3$.
Then we the following two paths over paths.
\begin{align*}
   q_1 \cto (q_2 \cto q_3) & : b_1 =^B_{p_1\ct (p_2\ct p_3)} b_4 \\
  (q_1 \cto q_2) \cto q_3  & : b_1 =^B_{(p_1\ct p_2) \ct p_3} b_4
\end{align*}
Since they are of different types, they cannot be compared directly, but there is an
equivalence $\varepsilon$ of type $\left( b_1 =^B_{p_1\ct (p_2\ct p_3)} b_4 \right) \equiv \left( b_1 =^B_{(p_1\ct p_2) \ct p_3} b_4 \right)$
constructed from the associativity law for paths of type $p_1\ct(p_2\ct p_3) = (p_1\ct p_2)\ct p_3$.
The associativity law for composition of paths over paths is an easily constructed identity of type $\varepsilon(q_1 \cto (q_2 \cto q_3)) = (q_1 \cto q_2)\cto q_3$.
For more information we refer the reader to the repositories with formalized proofs \cite{circleind-Dan}. 

In the rest of this section we work in a context with
$A : \UU$, $B : A \to \UU$, $a_i:A$, $b_i:B(a_i)$ for $i=1,2,3$, 
$p_i : a_i = a_{i+1}$ for $i=1,2$,

\begin{lemma}\label{lem:compo-over}
  For every $q : b_1 =^B_{p_1} b_2$, the
  function
  \[
    q \cto ({-}) : (b_2 =^B_{p_2} b_3) \to (b_1 =^B_{p_1\ct p_2} b_3)
  \]
  is an equivalence.
\end{lemma}
The proof is by induction on first $p_1$, and then $q$, and finally $p_2$.
Then conclude by reflexivity.

If $p=q$, then we can transport paths over $p$ to paths over $q$.

\begin{definition}\label{def:pathover-change-path}
  For every $p,q:a_1=a_2$ and $2$-dimensional path $\alpha : p = q$,
  transport along $\alpha$
  induces an equivalence $\cp{\alpha}: (b_1 =^B_p b_2) \equiv (b_1 =^B_q b_2)$.
  The function $\cp{\alpha}$ is called \emph{change path}, and is defined
  by induction on $\alpha$, setting $\cp{\refl{p}}\defeq \id_{b_1 =^B_p b_2}$.
\end{definition}

\begin{lemma}\label{lem:functorial-change-path}
  For every $p,q,r:a_1=a_2$ and 2-paths $\alpha : p = q$, $\beta : q = r$,
  we have $\cp{\alpha\ct\beta}=\cp{\beta}\circ\cp{\alpha}$.
\end{lemma}

The proof is by induction on $\beta$ (for right-recursive composition).

\begin{lemma}\label{lem:inv2-change-path}
  For every  $p,q:a_1=a_2$ and 2-path $\alpha : p = q$, taking
  $\alpha^- \defeq \ap{(\_)^{-1}}(\alpha)$, we have
  $(\cp{\alpha}(\hat p))^{-o} = \cp{\alpha^-}(\hat p^{-o})$
  for every $\hat p: b_1=^B_p b_2$.
\end{lemma}
 The proof is by induction on $\alpha$.

\begin{lemma}\label{lem:invlaw-change-path}
  For every  $p :a_1 = a_2$ define $\iota(p): p^{-1}\ct p = \refl{a_2}$
  by induction on $p$, by setting $\iota(\refl{a_1})\defeq \refl{\refl{a_1}}$.
  Then we have $\cp{\iota(p)}(\hat p^{-o} \cto {\hat p}) = \refl{b_2}$
  for every $\hat p: b_1=^B_p b_2$.
\end{lemma}
 The proof is by induction on first $p$, and then on $\hat p$.


\begin{definition}\label{lem:compo-ap-ap}
  For every  $p,p':a_1=a_2$, $q,q':a_2=a_3$ and 2-paths 
  $\alpha : p = p'$, $\beta : q = q'$, define
  $\apc(\alpha,\beta): (p\ct q)=(p'\ct q')$ by induction
  first on $\beta$ and then on $q$, 
  setting $\apc(\alpha,\refl{\refl{a_2}}) \defeq \alpha$.
  (This is well-typed for right-recursive composition.)
\end{definition}

\begin{lemma}\label{lem:compo-change-path}
  For every  $p,p':a_1=a_2$, $q,q':a_2=a_3$ and 2-paths 
  $\alpha : p = p'$, $\beta : q = q'$, we have
  $\cp{\apc(\alpha,\beta)}(\hat p \cto \hat q) = 
   \cp{\alpha}(\hat p) \cto Â \cp{\beta}(\hat q),$
  for every $\hat p: b_1=^B_p b_2$ and $\hat q: b_2=^B_q b_3$.
\end{lemma}
 The proof is by induction first on $\beta$, then on $q$, and finally on $\hat q$.




\section{Z-Torsors}\label{sec:ZTorsors}

Recall that pairs $(X,f)$ will be taken to be of type $\sum_{X:\UU}(X\to X)$.
Moreover, terms of propositional type whose precise form does not interest us are denoted by ``$!$''.
Nested pairs may be written as tuples.
With these notational simplifications, we rephrase some definitions from the introduction.

\begin{definition}\label{def:TorZ}
  The pointed type of $\zet$-torsors is defined by
  \begin{align*}
    \TorZ &\defeq \sum_{(X,f)}\Trunc{(\zet,s)=(X,f)}  \\
    \pt & \defeq ((\zet,s),\trunc{\refl{(\zet,s)}}) : \TorZ
  \end{align*}
  The variables $X,Y,Z$ will be used for elements of $\TorZ$, 
  as well as, by an abuse of notation, for their the first components.
  The equivalence $\ev_0$ is defined by
  \begin{align*}
    \ev_0: (\pt =_\TorZ \pt) & \to\zet \\
    p & \mapsto \mathsf{pr}_1(p)_*(0).
  \end{align*}
  The loop of $\TorZ$ is defined as ${\Zloop}\defeq\ev_0^{-1}(1)$,
  satisfying $\mathsf{pr}_1(\Zloop)_* = s$.
\end{definition}

The type $\TorZ$ is equivalent to the more traditionally defined 
type of $\ZZ$-torsors, but is more parsimonious.
(Traditionally, a $\ZZ$-torsor is defined as a nonempty set upon which the group $\ZZ$ acts freely and transitively.)
Another way to think of it is as the type of Cayley diagrams for $\ZZ$.

We remark that the pointed type $\TorZ$ is connected, that is, $\Trunc{\pt=Z}$ for all $Z:\TorZ$.

We introduce the induction principle for propositional truncation in the following form (compare with \cite[Ch. 6.9]{hottbook}).

\begin{definition}\label{def:proptruncind}
  If $A$ is a type and $B(x)$ is a family of propositions parametrized by the elements $a$ of $\Trunc A$,
  and given $g : \prod_{a:A} B(\trunc a)$, then there is a function $f : \prod_{x:\Trunc A} B(x)$.
  The \emph{computation rule} asserts that $f (\trunc a) \jdeq g(a)$ for all $a:A$.
\end{definition}

In {\UniMath} the induction principle holds, but not the computation rule for it.

\begin{lemma}\label{lem:dep-elim-TorZ}
If $P(Z)$ is a proposition for all $Z:\TorZ$, then $P(\pt)$ implies that $P(Z)$ holds for all $Z:\TorZ$.
\end{lemma}

\begin{proof}
Let $P(Z)$ be a proposition for all $Z:\TorZ$, and assume we have a proof
$p:P(\pt)$. Let $(X,f,t):\TorZ$, then $t :\Trunc{(\zet,s)=(X,f)}$.
Since $P(X,f,t)$ is a proposition, it suffices by truncation elimination
to prove $P(X,f,\trunc{e})$ for all $e:(\zet,s)=(X,f)$. 
By induction on $e$ we reduce the task to proving $P(\zet,s,\trunc{\refl{(Z,s)}})$, which is
the same as $P(\pt)$, so $p$ provides the proof.
\end{proof}

The proof $q: \prod_{Z:\TorZ} P(Z)$ constructed above has the property that $q(\pt)\jdeq p$ if the computation rule for the induction principle
for propositional truncation holds.

The aim of this section is to show that $\TorZ$ has the
universal property of the circle.
Although the same method works to derive both the recursion and the induction principles,
we opt to do the recursion principle first, as it is slightly simpler,
and prepares the way for the more complicated induction principle.

\subsection{Recursion in $\TorZ$}\label{sec:TorZ-recursion}

Fix $A:\UU$, $a:A$ and $p: a=_A a$.
We want to construct a function from $\TorZ$ to $A$ 
that maps $\pt$ to $a$ (definitionally),
and maps $\Zloop$ to $p$ (by action on paths).

All input data is present in $p$ and its type.
When defining types and functions depending on the input data, 
we use $p$ in various denotations to express this dependence. 

To be able to apply \cref{lem:dep-elim-TorZ}, 
we need to find a suitable proposition.
The idea is to expand $A$ to a $\Sigma$-type over $A$
(\cref{def:guided-null-hmtps}), 
and to prove that this $\Sigma$-type is contractible
(\cref{lem:guided-null-hmtps}).
We then obtain a function to $A$ by (double) projection
of this proof, as illustrated in \cref{fig:TorZ-recursion}.

\begin{figure}
\begin{tikzpicture} %\large
   \matrix (m) 
   [matrix of math nodes, row sep=2em, column sep=2em, ampersand replacement=\&]
    { 
    \sum\limits_{a':A} ~
    \prod\limits_{h: X\to a=a'} ~
    \prod\limits_{x:X} ~ h(f(x))=p\ct h(x)
    \&
    \&  
    \vphantom{\sum\limits_{a':A} ~
      \prod\limits_{h: X\to a=a'} ~
      \prod\limits_{x:X} ~ h(f(x))=p\ct h(x)}
    A
\\
\\
                     \& \TorZ \&      \\};

\draw[->>] (m-1-1) -- (m-3-2);
\draw[-> ] ( [xshift=-10pt] m-1-1) -- (m-1-3) node[midway,above]  {$\fst$};
\draw[->>] (m-1-3) -- (m-3-2);
\draw[->,dotted] (m-3-2) to[bend left=30] node[near end,left]{$\vec c_p$} (m-1-1);
\draw[->,dotted] (m-3-2) to[bend right=30] node[near end,right]{$c_p$} (m-1-3);

\end{tikzpicture}
\caption{\label{fig:TorZ-recursion}Factoring through a contractible type}
\end{figure}

\begin{definition}\label{def:guided-null-hmtps}
For every $(X,f)$, define
\begin{align*}\label{eq:TBD}
Q_p(X,f)&\defeq \sum_{a':A}~\sum_{h:X\to a=a'}~\prod_{x:X} h(f(x))=p\ct h(x).
\end{align*}
\end{definition}

\begin{lemma}\label{lem:guided-null-hmtps}
The type $Q_p(X,f)$ is contractible for all $(X,f,t):\TorZ$.
%with the center of contraction of $Q_p(X,f)$ 
%denoted by $\vec{c}_p(Z)\defeq(c_p(Z),\tilde{c}_p(Z),\hat{c}_p(Z))$.
\end{lemma}
\begin{proof}
  By \cref{lem:dep-elim-TorZ} it suffices to prove that $Q_p(\zet,s)$ is contractible.
  Note that $Q_p(\zet,s)$ is the total space of the family $R_p : A \to \UU$ defined by
  \[
    R_p(a') \defeq \sum_{h:\zet \to a=a'}~\prod_{z:\zet} h(z+1)=p\ct h(z).
  \]
  Note furthermore that $\sum_{a':A} a=a'$ is contractible with center $(a,\refl{a})$.
  Thus, to show that $Q_p(\zet,s)$ is contractible,
  it suffices to define an equivalence
  \[
    \varphi_{a'} : \biggl(\sum_{h:\zet \to a=a'}\prod_{z:\zet} h(z+1)=p\ct h(z)\biggr) \xrightarrow{\sim}{} (a=a')
  \]
  for each $a':A$.
  The intention is now to invoke \cref{thm:integers-univ-symm}.
  Indeed, let us define the constant type family $P_{a'}(z)\defeq(a=a')$
  over $\zet$. Also, define $f_{a'}(z) : P_{a'}(z) \to P_{a'}(z+1)$
  by $f_{a'}(z)(q) \defeq p \ct q$ for all $z:\zet$ and $q: a=a'$.
  Then each $f_{a'}(z)$ is an equivalence (with inverse $q \mapsto p^{-1}\ct q$).
  Thus, applying \cref{thm:integers-univ-symm}
  shows that $\varphi_{a'}$ is an equivalence,
  where $\varphi_{a'}(h,q) \defeq h(0)$.
\end{proof}

The center of contraction $\vec{c}_p(\pt)$ of $Q_p(\zet,s)$ is 
implicitly defined in the above proof 
and can be uncovered by a careful analysis of all proof-relevant steps.
First, the center of $\sum_{a':A} a=a'$ is $(a,\refl{a})$.
This center is pulled back by $\varphi_{a}$ to a center
$(a,c)$ of $Q_p(\zet,s)$, where $c$ is the center of 
$\varphi_{a}^{-1}(\refl{a})$ coming from the proof
that $\varphi_{a}$ is an equivalence. The latter proof
is the above instance of \cref{thm:integers-univ-symm}.
Unraveling this instance, and using the remark at the
end of the proof of \cref{thm:integers-univ-symm},
tells us that $c$ is a pair $(h,q)$ with $h(z)=p^z$
for all $z:\zet$. Indeed, $\varphi_{a}(h,q) = h(0) = \refl{a}$.
Moreover, $q$ has type $\prod_{z:\zet} h(z+1)=p\ct h(z)$.
Wrapping up, $\vec c_p(\pt)\defeq (a,h,q)$. In general we write
$\vec{c}_p(Z)\defeq(c_p(Z),\tilde{c}_p(Z),\hat{c}_p(Z))$.

The analysis in the previous paragraph
means we have achieved one of our goals,
namely that the function $c_p$ from $\TorZ$ to $A$ 
maps $\pt$ to $a$ definitionally.
%The situation is depicted in \cref{fig:TorZ-recursion}.
We will now deal with the other goal,
namely that $c_p$ acting on $\Zloop$ yields $p$.

\begin{lemma}\label{lem:ap-c-tilde-c}
For all $X,Y:\TorZ$, $e: X=Y$ and $x:X$ we have
$\ap{c_p}(e) = \tilde c_p(X,x)^{-1}\ct \tilde c_p(Y,\ptoe{e}(x))$,
where $\ptoe{e}\defeq \mathsf{pr}_1(e)_* : X\to Y$.
\end{lemma}
\begin{proof}
By using induction on $e$ we only have to check the case where
$X\jdeq Y$ and $e\jdeq\refl{X}$. In this case $\ap{c_p}(e)$ is
$\refl{c_p(X)}$. On the right-hand side we get $\ptoe{e}(x)\jdeq x$,
and hence this side simplifies to a reflexivity path of
the correct type, as $\tilde c_p(X,x)$ has type $a=c_p(X)$.
\end{proof}

We apply the above lemma with $X\jdeq Y\jdeq \pt$ and $e\jdeq{\Zloop}: \pt=\pt$.
Then we have $\ptoe{e}(x)=s(x)=x+1$. We can take $x\defeq 0$ and get by
the analysis after the proof of \cref{lem:guided-null-hmtps}
that $\tilde c_p(\pt,1) = p$ and $\tilde c_p(\pt,0) = \refl{a}$.
It follows that $\ap{c_p}(\Zloop) = p$ by \cref{lem:ap-c-tilde-c}.
This means we have achieved our second goal as well.
We summarize the results in the following recursion principle for $\TorZ$.
In the next section we will prove an induction principle for $\TorZ$.

\begin{definition}\label{def:TorZrecursor}
  The function ${\rec}_A(a,p) \defeq c_p$ as defined after 
  \cref{lem:guided-null-hmtps} has type
  \[
    {\rec}_A : \sum_{a:A}(a=a) ~~\to~~ (\TorZ \to A),
  \]
  and satisfies ${\rec}_A(a,p)(\pt) \jdeq a$ and 
  $\ap{{\rec}_A(a,p)}(\Zloop) = p$.
\end{definition}

\subsection{Induction in $\TorZ$}\label{sec:TorZ-induction}

Fix $A:\TorZ\to\UU$, $a:A(\pt)$, and $p: a=^A_{\Zloop} a$.
On the basis of this input data, we will construct a function of 
type $\prod_{Z:\TorZ} A(Z)$ that maps $\pt$ to $a$ (definitionally),
and maps $\Zloop$ to $p$ (by dependent action on paths).
We follow the pattern of the non-dependent case
in \cref{sec:TorZ-recursion}, but keep in mind that 
$A$ is now not constant and $p$ is a \emph{path over a path}.

The following lemma follows from the fact that $\zet$ is a set
and $s: \zet\to\zet$ is an equivalence.

\begin{lemma}\label{lem:paths-in-TorZ}
  Suppose $p : (\zet,s)=(X,f)$.  Then $X$ is a set and $f: X\to X$ is an equivalence.
  Morever, with $\ptoe{p}\defeq \mathsf{pr}_1(p)_*$ the equivalence induced by $p$, we have 
  $f^n(x) = (\ptoe{p}\circ s^n \circ \ptoe{p}^{-1})(x) = \ptoe{p}(\ptoe{p}^{-1}(x)+n)$, 
  for all $n:\zet$ and $x:X$.
\end{lemma}

Note that for fixed $x:X$ the expression $\ptoe{p}^{-1}(x)+n$ can be seen as 
the function shifting $n:\zet$ by $\ptoe{p}^{-1}(x)$ positions, indeed an equivalence.
Hence $f^n(x)$ as a function of $n$ is an equivalence from $Z$ to $X$.
For simplicity, we may denote $f^n(x)$ by $x+n$.

\begin{definition}\label{def:loop-s-iterated}
  For every $Z\defeq(X,f,t):\TorZ$ and $x:X$, 
  define $s^Z_x: \pt =_\TorZ Z$ by the equivalence
  $e_x(n)\defeq f^n(x)$ using the univalence axiom. Indeed, 
  $f\circ e_x = e_x \circ s$, as both functions map $n$ to $f^{n+1}(x)$. 
\end{definition}

Applying \cref{thm:integers-univ-symm} we will need two auxiliary 
results about the paths $s^\pt_x$, one for $x=0$ and 
the other for the (symmetric) induction step.
In \cref{def:loop-s-iterated}, if $Z\jdeq\pt$ and $x=0$, we get $e_0 = \id$.
Applying the univalence axiom gives thus the first result.

\begin{lemma}\label{lem:s-pt-zero}
  There is a path $\gamma_0 : \refl{\pt} = s^\pt_0$. 
\end{lemma}

For the second result, note that prefixing $s^Z_x$ by ${\Zloop}$ 
amounts to precomposing the equivalence $e_x$ with $s$. 
We have $(e_x\circ s)(n) = e_x(n+1) = f^{n+1}(x) = f^n(f(x)) =e_{f(x)}(n)$,
so $e_x\circ s = e_{x+1}$. Applying the univalence axiom we get:

\begin{lemma}\label{lem:loop-s-iterated}
  For every $Z\defeq(X,f,t):\TorZ$ and $x:X$, we have a path
  ${\delta^Z_x}: {\Zloop} \ct s^Z_x = s^Z_{x+1}$. 
\end{lemma}

Now we are ready to derive the induction principle using the same 
technique as for the recursion principle. We reuse notations as much as
possible, but take care that all types are different.

\begin{definition}\label{def:guided-null-hmtps-dep}
For every $Z\defeq(X,f,t):\TorZ$, define
\begin{align*}\label{eq:TBD}
Q_p(Z)&\defeq \sum_{a' : A(Z)}~\sum_{h : \prod_{x:X} a =^A_{s^Z_x} a'}~\prod_{x:X} h(f(x)) = \cp{\delta^Z_x}(p\cto h(x)),
\end{align*}
where $\delta^Z_x$ comes from \cref{lem:loop-s-iterated}.
\end{definition}


\begin{lemma}\label{lem:guided-null-hmtps-dep}
  For every $Z:\TorZ$, the type $Q_p(Z)$ is contractible.
\end{lemma}
\begin{proof}
  By \cref{lem:dep-elim-TorZ} it suffices to prove that $Q_p(\pt)$ is contractible.
  We have $Q_p(\pt)\jdeq \sum_{a':A(\pt)} R(a')$ for $R : A(\pt) \to \UU$ defined by
  \[
    R_p(a') \defeq \sum_{h : \prod_{z:\zet} a =^A_{s^\pt_z} a'}~
    \prod_{z:\zet} h(z+1) = \cp{\delta^\pt_z}(p \cto h(z)).
  \]
  We show that $\sum_{a':A(\pt)} (a =^A_{s^\pt_0} {a'})$ is contractible.
  Let $\rrfl$ be the reflexivity path at $a$ over $\refl{\pt}$.
  Note that $\sum_{a':A(\pt)} (a =^A_{\refl{\pt}} a') \jdeq \sum_{a':A(\pt)} (a = a')$
  is contractible with center $(a,\rrfl)$. By \cref{lem:s-pt-zero}
  $\sum_{a':A(\pt)} (a =^A_{s^\pt_0} {a'})$ is contractible with center
  $(a,\cp{\gamma_0}(\rrfl))$.

  Thus, to show that $Q_p(\pt)$ is contractible,
  it suffices to define an equivalence
  \[
    \varphi_{a'} : R_p(a') \xrightarrow{\sim}{} (a =^A_{s^\pt_0} {a'})
  \]
  for each $a' : A(\pt)$.
  We again invoke \cref{thm:integers-univ-symm},
  this time with the family $P_{a'} : \zet \to \UU$ given 
  by $P_{a'}(z) \defeq (a =^A_{s^\pt_z} {a'})$
  and the equivalences $f_{a'} : \prod_{z:\zet} P_{a'}(z)\equiv P_{a'}(z+1)$ 
  given by $f_{a'}(z) \defeq \cp{\delta^\pt_z}(p \cto ({-}))$.
  Thus, applying \cref{thm:integers-univ-symm}
  shows that $\varphi_{a'}$ is an equivalence,
  where $\varphi_{a'}(h,q) \defeq h(0)$.
\end{proof}

The center of contraction $\vec{c}_p(\pt)$ of $Q_p(\pt)$ is 
defined in the above proof as $\varphi_{a}^{-1}(a,\cp{\gamma_0}(\rrfl))$, 
which is again a triple $(a,h,q)$. In general we write
$\vec{c}_p(Z)\defeq(c_p(Z),\tilde{c}_p(Z),\hat{c}_p(Z))$
for the center of contraction of $Q_p(Z)$.
We immediately get $c_p(\pt)\defeq a$ and will proceed to
elaborate $\apd{c_p}(\Zloop)$ (see \cite[Ch. 2.3]{hottbook} for $\apd{\_}$).

%\begin{figure}
%\caption{\label{fig:TorZ-induction}LET'S HAVE SOME INFORMATIVE PICTURE}
%\end{figure}

\begin{lemma}\label{lem:s-X-x-*-e}
  For all $X,Y:\TorZ$, $e: X=Y$ and $x:X$ we have a path 
  $\varepsilon_{e,x} : (s^X_x)^{-1} \ct s^Y_{\ptoe{e}(x)} = e$,
  where $\ptoe{e}\defeq \mathsf{pr}_1(e)_* : X\to Y$.
% Moreover, $\varepsilon_{\refl{X},x} \defeq \iota(s^X_x)$.
\end{lemma}
\begin{proof}
By induction on $e$ it suffices to give
$\varepsilon_{\refl{X},x} : (s^X_x)^{-1} \ct s^X_x = \refl{X}$,
since $\mathsf{pr}_1(\refl{X})_*(x) \jdeq x$.
Hence we set $\varepsilon_{\refl{X},x} \defeq \iota(s^X_x)$,
with $\iota$ as in \cref{lem:invlaw-change-path}. 
\end{proof}

%The following lemmas use pathover reversal denoted by $({-})^{-o}$.

\begin{lemma}\label{lem:apd-c-tilde-c}
For all $X,Y:\TorZ$, $e: X=Y$ and $x:X$ we have
$\apd{c_p}(e) = \cp{\varepsilon_{e,x}}
(\tilde c_p(X,x)^{-o}\cto \tilde c_p(Y,e(x)))$.
\end{lemma}
\begin{proof}
Induction on $e$ reduces the proof to the case $e\jdeq\refl{X}: X=X$,
which follows from \cref{lem:invlaw-change-path} and \cref{lem:s-X-x-*-e}.
It remains to check that the general statement of the lemma is well-typed.
We have the following paths over paths.
\begin{align*}
\apd{c_p}(e) &: (c_p(X) =^A_e c_p(Y))\\
\tilde c_p(Y,e(x)) &:  (a =^A_{s^Y_{e(x)}} c_p(Y))\\
\tilde c_p(X,x)^{-o} &: (c_p(X) =^A_{(s^X_x)^{-1}} a)\\
\tilde c_p(X,x)^{-o} \cto c_p(Y,e(x)) &: 
     (c_p(X) =^A_{(s^X_x)^{-1}\ct s^Y_{e(x)}} c_p(Y))\\
\end{align*}
In order to make ends meet between the first and the fourth typing
we invoke \cref{lem:s-X-x-*-e} and \cref{def:pathover-change-path}.
\end{proof}

Recall the center of contraction $\varphi_{a}^{-1}(a,\cp{\gamma_0}(\rrfl))$
of $Q_p(\pt)$, denoted by $(c_p(\pt),\tilde{c}_p(\pt),\hat{c}_p(\pt))$.
The type of $h\defeq\tilde{c}_p(\pt)$ is $\prod_{z:\zet} a =^A_{s^\pt_z} a$ and
the type of $q\defeq\hat{c}_p(\pt)$ is $\prod_{z:\zet} h(z+1) = \cp{\delta^\pt_z}(p \cto h(z))$.
We know $\varphi_{a}(h,q) \jdeq h(0) = \cp{\gamma_0}(\rrfl)$, 
so $\tilde c_p(\pt,0) = \cp{\gamma_0}(\rrfl)$.
Using $q$ we also know that 
$\tilde c_p(\pt,1) \jdeq h(1) = \cp{\delta^\pt_0}(p \cto h(0))$.
We now have enough information to verify $\apd{c_p}(\Zloop)=p$,
which by \cref{lem:apd-c-tilde-c} reduces to 
\[
\cp{\varepsilon_{\Zloop,0}}
((\cp{\gamma_0}(\rrfl))^{-o}\cto 
\cp{\delta^\pt_0}(p \cto \cp{\gamma_0}(\rrfl))) = p.
\]

A great simplification is obtained by using that $\TorZ$ is a groupoid:
all 2-paths having the same endpoints are equal.
Hence the functions $\cp{\alpha}$ only depend on the (path-)type
of $\alpha$, and we may replace the subscript $\alpha$ by its type.
However, if $\alpha$ is shorter than its type we may 
prefer to keep $\alpha$ in $\cp{\alpha}$.
Also, as $\cp{\refl{}}$ is the identity, so is any $\cp{\alpha}$
when the endpoints of $\alpha$ are definitionally equal. 
We make extensive use of this and of the functions and
lemmas from \cref{sec:pathovers}.

Abbreviate $s_0 \defeq s^\pt_0$, $s_1 \defeq s^\pt_1$, 
then $\varepsilon_{\Zloop,0} : s_0^{-1} \ct s_1 = {\Zloop}$.
We split the latter identity in a sequence of identities:
\[
s_0^{-1} \ct s_1 \stackrel{\alpha}{=} 
\refl{\pt}\ct(\Zloop\ct s_0) \stackrel{\beta}{=} 
\refl{\pt}\ct(\Zloop\ct\refl{\pt})\stackrel{\gamma}{=} {\Zloop}
\]
Here $\alpha,\beta$ are constructed with $\apc$ so as to
enable the application of \cref{lem:compo-change-path}.
We now calculate:

\begin{align*}
\cp{\alpha\ct\beta\ct\gamma}
((\cp{\refl{\pt} = s_0}(\rrfl))^{-o} \cto
   \cp{\Zloop\ct s_0 = s_1}(p\cto\cp{\refl{\pt} = s_0}(\rrfl)))&= \\
\cp{\gamma}(\cp{\beta}(\cp{\alpha}
((\cp{\refl{\pt} = s_0^{-1}}(\rrfl)) \cto
   \cp{\Zloop\ct s_0 = s_1}(p\cto\cp{\refl{\pt} = s_0}(\rrfl)))))&= \\
\cp{\gamma}(\cp{\beta}
(\rrfl \cto
   (p\cto\cp{\refl{\pt} = s_0}(\rrfl))))&= \\
\cp{\gamma}(\rrfl\cto(p\cto\rrfl))&= p. 
\end{align*}

\section{Conclusion and Future Research}
We have proved the induction principle of the circle for $\TorZ$:
\[
{\ind}_A : \sum_{a:A(\pt)}(a=_\Zloop a) ~~\to~~ \prod_{Z:\TorZ} A(Z),
\]
with ${\ind}_A$ mapping $(a,p)$ to $c_p$ satisfying $c_p(\pt) \jdeq a$ 
and $\apd{c_p}(\Zloop) = p$.

It would be interesting to see whether our method can be generalised
from $\TorZ$ to the type of $G$-torsors, where $G$ is a free group with
a set of generators with decidable equality.

\section{Acknowledgements}
The authors acknowledge the support of the Centre for Advanced Study (CAS)
at the Norwegian Academy of Science and Letters
in Oslo, Norway, which funded and hosted the research project Homotopy Type Theory and Univalent Foundations during the academic year 2018/19. 
Grayson also acknowledges the support of the Air Force Office of Scientific Research, through a grant to Carnegie Mellon University.

\bibliographystyle{amsplain}
\bibliography{papers}

% \printindex
\end{document}
% Local Variables:
% fill-column: 144
% latex-block-names: ("lemma" "theorem" "remark" "definition" "corollary" "fact" "properties" "conjecture" "proof" "question" "proposition")
% TeX-master: t
% compile-command: "make ZTors.pdf"
% End:

